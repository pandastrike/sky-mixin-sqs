// Generated by CoffeeScript 1.12.2
(function() {
  var Method, _assoc, _flatten, add, all, any, assoc, async, average, binary, collect, curry, delimit, each, first, flatten, fold, foldr, isArray, isDefined, isFunction, isIterable, isIterator, isReactor, isReagent, iterator, negate, next, noOp, producer, push, reactor, reduce, reduceRight, ref, ref1, ref2, ref3, second, start, sum, ternary, zip;

  ref = require("./iterator"), isIterable = ref.isIterable, iterator = ref.iterator, isIterator = ref.isIterator, isIterator = ref.isIterator, next = ref.next;

  ref1 = require("./reactor"), isReagent = ref1.isReagent, reactor = ref1.reactor, isReactor = ref1.isReactor, isReactor = ref1.isReactor;

  producer = require("./adapters").producer;

  ref2 = require("fairmont-core"), curry = ref2.curry, binary = ref2.binary, ternary = ref2.ternary, noOp = ref2.noOp, negate = ref2.negate;

  ref3 = require("fairmont-helpers"), isFunction = ref3.isFunction, isDefined = ref3.isDefined, isArray = ref3.isArray, async = ref3.async, first = ref3.first, push = ref3.push, second = ref3.second, add = ref3.add;

  Method = require("fairmont-multimethods").Method;

  next = function(i) {
    return i.next();
  };

  fold = Method.create();

  Method.define(fold, isFunction, (function(x) {
    return true;
  }), isDefined, function(f, x, y) {
    return fold(x, f, producer(y));
  });

  Method.define(fold, isFunction, (function(x) {
    return true;
  }), isIterator, function(f, x, i) {
    var done, ref4, value;
    while (true) {
      ref4 = next(i), done = ref4.done, value = ref4.value;
      if (done) {
        break;
      }
      x = f(x, value);
    }
    return x;
  });

  Method.define(fold, isFunction, (function(x) {
    return true;
  }), isReactor, async(function*(f, x, i) {
    var done, ref4, value;
    while (true) {
      ref4 = (yield next(i)), done = ref4.done, value = ref4.value;
      if (done) {
        break;
      }
      x = f(x, value);
    }
    return x;
  }));

  Method.define(fold, isFunction, (function(x) {
    return true;
  }), isArray, function(f, x, ax) {
    return ax.reduce(f, x);
  });

  reduce = fold = curry(ternary(fold));

  foldr = Method.create();

  Method.define(foldr, isFunction, (function(x) {
    return true;
  }), isDefined, function(f, x, y) {
    return foldr(f, x, producer(y));
  });

  Method.define(foldr, isFunction, (function(x) {
    return true;
  }), isIterator, function(f, x, i) {
    return (collect(i)).reduceRight(f, x);
  });

  Method.define(foldr, isFunction, (function(x) {
    return true;
  }), isReactor, function(f, x, i) {
    return (collect(i)).then(function(ax) {
      return ax.reduceRight(f, x);
    });
  });

  Method.define(foldr, isFunction, (function(x) {
    return true;
  }), isArray, function(f, x, ax) {
    return ax.reduceRight(f, x);
  });

  reduceRight = foldr = curry(ternary(foldr));

  collect = function(i) {
    return reduce(push, [], i);
  };

  each = curry(function(f, i) {
    var g;
    g = function(_, x) {
      f(x);
      return _;
    };
    return reduce(g, void 0, i);
  });

  start = reduce(noOp, void 0);

  any = Method.create();

  Method.define(any, isFunction, isDefined, function(f, x) {
    return any(f, producer(x));
  });

  Method.define(any, isFunction, isIterator, function(f, i) {
    var done, ref4, value;
    while (true) {
      ref4 = next(i), done = ref4.done, value = ref4.value;
      if (done || (f(value))) {
        break;
      }
    }
    return !done;
  });

  Method.define(any, isFunction, isReactor, async(function*(f, i) {
    var done, ref4, value;
    while (true) {
      ref4 = (yield next(i)), done = ref4.done, value = ref4.value;
      if (done || (f(value))) {
        break;
      }
    }
    return !done;
  }));

  any = curry(binary(any));

  all = Method.create();

  Method.define(all, isFunction, isDefined, function(f, x) {
    return all(f, producer(x));
  });

  Method.define(all, isFunction, isIterator, function(f, i) {
    return !any(negate(f), i);
  });

  Method.define(all, isFunction, isReactor, async(function*(f, i) {
    return !((yield any(negate(f), i)));
  }));

  all = curry(binary(all));

  zip = Method.create();

  Method.define(zip, isFunction, isDefined, isDefined, function(f, x, y) {
    return zip(f, producer(x), producer(y));
  });

  Method.define(zip, isFunction, isIterator, isIterator, function(f, i, j) {
    return iterator(function() {
      var x, y;
      x = next(i);
      y = next(j);
      if (!x.done && !y.done) {
        return {
          value: f(x.value, y.value),
          done: false
        };
      } else {
        return {
          done: true
        };
      }
    });
  });

  _assoc = function(object, arg) {
    var key, value;
    key = arg[0], value = arg[1];
    object[key] = value;
    return object;
  };

  assoc = function(ax) {
    return reduce(_assoc, {}, ax);
  };

  _flatten = function(ax, a) {
    if (isIterable(a)) {
      return ax.concat(flatten(a));
    } else {
      ax.push(a);
      return ax;
    }
  };

  flatten = function(ax) {
    return fold(_flatten, [], ax);
  };

  sum = function(ax) {
    return fold(add, 0, ax);
  };

  average = function(i) {
    var f, j;
    j = 0;
    f = function(r, n) {
      return r += (n - r) / ++j;
    };
    return fold(f, 0, i);
  };

  delimit = curry(function(d, i) {
    var f;
    f = function(r, s) {
      if (r === "") {
        return r += s;
      } else {
        return r += d + s;
      }
    };
    return fold(f, "", i);
  });

  module.exports = {
    reduce: reduce,
    fold: fold,
    reduce: reduce,
    foldr: foldr,
    reduceRight: reduceRight,
    collect: collect,
    each: each,
    start: start,
    any: any,
    all: all,
    zip: zip,
    assoc: assoc,
    flatten: flatten,
    sum: sum,
    average: average,
    delimit: delimit
  };

}).call(this);
