// Generated by CoffeeScript 1.12.2
(function() {
  var Core, Helpers, Method, _pull, apply, binary, combine, compose, curry, events, flow, follow, identity, include, isArray, isDefined, isEmpty, isFunction, isFunctionList, isIterable, isIterator, isObject, isProducer, isPromise, isReactor, isReagent, isSource, isString, isType, iterator, next, pipe, producer, promise, property, pull, queue, reactor, ref, ref1, repeat, stream,
    slice = [].slice;

  Core = require("fairmont-core");

  Helpers = require("fairmont-helpers");

  Method = require("fairmont-multimethods").Method;

  apply = Core.apply, pipe = Core.pipe, curry = Core.curry, compose = Core.compose, binary = Core.binary, identity = Core.identity;

  include = Helpers.include, property = Helpers.property, isEmpty = Helpers.isEmpty;

  isType = Helpers.isType, isDefined = Helpers.isDefined;

  isString = Helpers.isString, isObject = Helpers.isObject, isArray = Helpers.isArray, isFunction = Helpers.isFunction;

  promise = Helpers.promise, follow = Helpers.follow, isPromise = Helpers.isPromise;

  producer = require("./adapters").producer;

  ref = require("./iterator"), isIterable = ref.isIterable, isIterator = ref.isIterator, isIterator = ref.isIterator, iterator = ref.iterator, next = ref.next;

  ref1 = require("./reactor"), isReagent = ref1.isReagent, isReactor = ref1.isReactor, isReactor = ref1.isReactor, reactor = ref1.reactor;

  isProducer = function(x) {
    return (isIterator(x)) || (isReactor(x));
  };

  producer = Method.create();

  Method.define(producer, isIterable, function(x) {
    return iterator(x);
  });

  Method.define(producer, isReagent, function(x) {
    return reactor(x);
  });

  Method.define(producer, isProducer, identity);

  Method.define(producer, isPromise, function(p) {
    var _p;
    _p = p.then(function(x) {
      return iterator(x);
    });
    return reactor(function() {
      return _p.then(function(i) {
        return next(i);
      });
    });
  });

  repeat = function(x) {
    return iterator(function() {
      return {
        done: false,
        value: x
      };
    });
  };

  _pull = function(arg) {
    var done, value;
    done = arg.done, value = arg.value;
    if (done) {
      return follow({
        done: done
      });
    } else if ((value != null ? value.then : void 0) != null) {
      return value.then(function(value) {
        return {
          done: done,
          value: value
        };
      });
    } else {
      return {
        done: done,
        value: value
      };
    }
  };

  pull = Method.create();

  Method.define(pull, isDefined, function(x) {
    return pull(producer(x));
  });

  Method.define(pull, isIterator, function(i) {
    return reactor(function() {
      return _pull(next(i));
    });
  });

  Method.define(pull, isReactor, function(i) {
    return reactor(function() {
      return (next(i)).then(_pull);
    });
  });

  queue = function() {
    var dequeue, done, end, enqueue, pending, resolved;
    done = false;
    pending = [];
    resolved = [];
    end = function() {
      var j, len, resolve, results;
      done = true;
      results = [];
      for (j = 0, len = pending.length; j < len; j++) {
        resolve = pending[j].resolve;
        results.push(resolve({
          done: done
        }));
      }
      return results;
    };
    enqueue = function(value) {
      var ref2, reject, resolve;
      if (!done) {
        if (pending.length === 0) {
          return resolved.push({
            done: done,
            value: value
          });
        } else {
          ref2 = pending.shift(), resolve = ref2.resolve, reject = ref2.reject;
          return follow(value).then(function(value) {
            return resolve({
              done: done,
              value: value
            });
          })["catch"](reject);
        }
      }
    };
    dequeue = function() {
      if (resolved.length === 0) {
        if (!done) {
          return promise(function(resolve, reject) {
            return pending.push({
              resolve: resolve,
              reject: reject
            });
          });
        } else {
          return {
            done: done
          };
        }
      } else {
        return resolved.shift();
      }
    };
    return {
      enqueue: enqueue,
      dequeue: reactor(dequeue),
      end: end
    };
  };

  combine = function() {
    var count, dequeue, end, enqueue, j, len, p, px, ref2, wait;
    px = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    count = px.length;
    ref2 = queue(), dequeue = ref2.dequeue, enqueue = ref2.enqueue, end = ref2.end;
    wait = function(p) {
      return follow(next(p)).then(function(arg) {
        var done, value;
        done = arg.done, value = arg.value;
        if (done) {
          if (--count === 0) {
            return end();
          }
        } else {
          enqueue(value);
          return wait(p);
        }
      })["catch"](function(error) {
        return enqueue(error);
      });
    };
    for (j = 0, len = px.length; j < len; j++) {
      p = px[j];
      wait(producer(p));
    }
    return dequeue;
  };

  events = Method.create();

  isSource = compose(isFunction, property("on"));

  (function(defaults) {
    Method.define(events, isString, isSource, function(name, source) {
      return events(include({
        name: name
      }, defaults), source);
    });
    return Method.define(events, isObject, isSource, function(map, source) {
      var dequeue, end, enqueue, ref2;
      map = include(defaults, map);
      ref2 = queue(), enqueue = ref2.enqueue, dequeue = ref2.dequeue, end = ref2.end;
      source.on(map.name, function() {
        var ax, value;
        ax = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        value = ax.length < 2 ? ax[0] : ax;
        return enqueue(value);
      });
      source.on(map.end, end);
      source.on(map.error, enqueue);
      return dequeue;
    });
  })({
    end: "end",
    error: "error"
  });

  events = curry(binary(events));

  stream = events("data");

  flow = Method.create();

  isFunctionList = function() {
    var f, fx, j, len;
    fx = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    for (j = 0, len = fx.length; j < len; j++) {
      f = fx[j];
      if (!isFunction(f)) {
        return false;
      }
    }
    return true;
  };

  Method.define(flow, isDefined, isFunctionList, function() {
    var fx, x;
    x = arguments[0], fx = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    return flow.apply(null, [producer(x)].concat(slice.call(fx)));
  });

  Method.define(flow, isArray, function(ax) {
    return flow.apply(null, ax);
  });

  Method.define(flow, isProducer, isFunctionList, function() {
    var fx, p;
    p = arguments[0], fx = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    return apply(pipe.apply(null, fx), p);
  });

  module.exports = {
    producer: producer,
    pull: pull,
    repeat: repeat,
    queue: queue,
    events: events,
    stream: stream,
    flow: flow,
    combine: combine
  };

}).call(this);
