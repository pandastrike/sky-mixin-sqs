// Generated by CoffeeScript 1.12.2
(function() {
  var Method, accumulate, async, binary, compact, curry, filter, isDefined, isFunction, isIterator, isReactor, isStreamLike, iterator, iteratorFunction, lines, map, negate, next, partition, pour, producer, project, property, pump, query, reactor, reactorFunction, ref, ref1, ref2, ref3, reject, select, take, takeN, tee, ternary, throttle, where,
    slice = [].slice;

  ref = require("fairmont-core"), curry = ref.curry, binary = ref.binary, ternary = ref.ternary, negate = ref.negate;

  ref1 = require("fairmont-helpers"), isFunction = ref1.isFunction, isDefined = ref1.isDefined, property = ref1.property, query = ref1.query, async = ref1.async;

  Method = require("fairmont-multimethods").Method;

  ref2 = require("./iterator"), iterator = ref2.iterator, iteratorFunction = ref2.iteratorFunction, isIterator = ref2.isIterator, next = ref2.next;

  ref3 = require("./reactor"), reactor = ref3.reactor, reactorFunction = ref3.reactorFunction, isReactor = ref3.isReactor;

  producer = require("./adapters").producer;

  map = Method.create();

  Method.define(map, isFunction, isDefined, function(f, x) {
    return map(f, producer(x));
  });

  Method.define(map, isFunction, isIterator, function(f, i) {
    return iterator(function() {
      var done, ref4, value;
      ref4 = next(i), done = ref4.done, value = ref4.value;
      if (done) {
        return {
          done: done
        };
      } else {
        return {
          done: done,
          value: f(value)
        };
      }
    });
  });

  Method.define(map, isFunction, isReactor, function(f, r) {
    return reactor(function() {
      return (next(r)).then(function(arg) {
        var done, value;
        done = arg.done, value = arg.value;
        if (done) {
          return {
            done: done
          };
        } else {
          return {
            done: done,
            value: f(value)
          };
        }
      });
    });
  });

  map = curry(binary(map));

  select = Method.create();

  Method.define(select, isFunction, isDefined, function(f, x) {
    return select(f, producer(x));
  });

  Method.define(select, isFunction, isIterator, function(f, i) {
    return iterator(function() {
      var done, ref4, value;
      while (true) {
        ref4 = next(i), done = ref4.done, value = ref4.value;
        if (done || (f(value))) {
          break;
        }
      }
      return {
        done: done,
        value: value
      };
    });
  });

  Method.define(select, isFunction, isReactor, function(f, i) {
    return reactor(async(function*() {
      var done, ref4, value;
      while (true) {
        ref4 = (yield next(i)), done = ref4.done, value = ref4.value;
        if (done || f(value)) {
          break;
        }
      }
      return {
        done: done,
        value: value
      };
    }));
  });

  select = filter = curry(binary(select));

  reject = curry(function(f, i) {
    return select(negate(f), i);
  });

  accumulate = Method.create();

  Method.define(accumulate, isFunction, (function(x) {
    return true;
  }), isDefined, function(f, k, x) {
    return accumulate(f, k, producer(x));
  });

  Method.define(accumulate, isFunction, (function(x) {
    return true;
  }), isIterator, function(f, k, i) {
    return iterator(function() {
      var done, ref4, value;
      ref4 = next(i), done = ref4.done, value = ref4.value;
      if (!done) {
        k = f(k, value);
        return {
          value: k,
          done: false
        };
      } else {
        return {
          done: done
        };
      }
    });
  });

  Method.define(accumulate, isFunction, (function(x) {
    return true;
  }), isReactor, function(f, k, r) {
    return reactor(function() {
      return (next(r)).then(function(arg) {
        var done, value;
        done = arg.done, value = arg.value;
        if (!done) {
          k = f(k, value);
          return {
            value: k,
            done: false
          };
        } else {
          return {
            done: done
          };
        }
      });
    });
  });

  accumulate = curry(ternary(accumulate));

  project = curry(function(p, i) {
    return map(property(p), i);
  });

  compact = select(isDefined);

  partition = Method.create();

  Method.define(partition, Number, isDefined, function(n, x) {
    return partition(n, producer(x));
  });

  Method.define(partition, Number, isIterator, function(n, i) {
    return iterator(function() {
      var batch, done, ref4, value;
      batch = [];
      while (true) {
        ref4 = next(i), done = ref4.done, value = ref4.value;
        if (done) {
          break;
        }
        batch.push(value);
        if (batch.length === n) {
          break;
        }
      }
      if (done && batch.length === 0) {
        return {
          done: done
        };
      } else {
        return {
          value: batch,
          done: done
        };
      }
    });
  });

  Method.define(partition, Number, isReactor, function(n, i) {
    return reactor(async(function*() {
      var batch, done, ref4, value;
      batch = [];
      while (true) {
        ref4 = (yield next(i)), done = ref4.done, value = ref4.value;
        if (done) {
          break;
        }
        batch.push(value);
        if (batch.length === n) {
          break;
        }
      }
      if (done && batch.length === 0) {
        return {
          done: done
        };
      } else {
        return {
          value: batch,
          done: done
        };
      }
    }));
  });

  partition = curry(binary(partition));

  take = Method.create();

  Method.define(take, isFunction, isDefined, function(f, x) {
    return take(f, producer(x));
  });

  Method.define(take, isFunction, isIterator, function(f, i) {
    return iterator(function() {
      var done, ref4, value;
      if (!done) {
        ref4 = next(i), done = ref4.done, value = ref4.value;
        if (!done && (f(value))) {
          return {
            value: value,
            done: false
          };
        } else {
          return {
            done: true
          };
        }
      }
    });
  });

  take = curry(binary(take));

  takeN = (function() {
    var f;
    f = function(n, i) {
      if (i == null) {
        i = 0;
      }
      return function() {
        return i++ < n;
      };
    };
    return function(n, i) {
      return take(f(n), i);
    };
  })();

  where = curry(function(example, i) {
    return select(query(example), i);
  });

  pour = Method.create();

  Method.define(pour, isFunction, isDefined, function(f, x) {
    return pour(f, producer(x));
  });

  Method.define(pour, isFunction, isIterator, function(f, i) {
    var lines, remainder;
    lines = [];
    remainder = "";
    return iterator(function() {
      var done, first, j, last, ref4, ref5, value;
      if (lines.length > 0) {
        return {
          value: lines.shift(),
          done: false
        };
      } else {
        ref4 = next(i), value = ref4.value, done = ref4.done;
        if (!done) {
          ref5 = f(value), first = ref5[0], lines = 3 <= ref5.length ? slice.call(ref5, 1, j = ref5.length - 1) : (j = 1, []), last = ref5[j++];
          first = remainder + first;
          remainder = last;
          return {
            value: first,
            done: done
          };
        } else if (remainder !== "") {
          value = remainder;
          remainder = "";
          return {
            value: value,
            done: false
          };
        } else {
          return {
            done: done
          };
        }
      }
    });
  });

  Method.define(pour, isFunction, isReactor, function(f, i) {
    var lines, remainder;
    lines = [];
    remainder = "";
    return reactor(async(function*() {
      var done, first, j, last, ref4, ref5, value;
      if (lines.length > 0) {
        return {
          value: lines.shift(),
          done: false
        };
      } else {
        ref4 = (yield next(i)), value = ref4.value, done = ref4.done;
        if (!done) {
          ref5 = f(value), first = ref5[0], lines = 3 <= ref5.length ? slice.call(ref5, 1, j = ref5.length - 1) : (j = 1, []), last = ref5[j++];
          first = remainder + first;
          remainder = last;
          return {
            value: first,
            done: done
          };
        } else if (remainder !== "") {
          value = remainder;
          remainder = "";
          return {
            value: value,
            done: false
          };
        } else {
          return {
            done: done
          };
        }
      }
    }));
  });

  pour = curry(binary(pour));

  lines = pour(function(s) {
    return s.toString().split("\n");
  });

  tee = Method.create();

  Method.define(tee, isFunction, isDefined, function(f, x) {
    return tee(f, producer(x));
  });

  Method.define(tee, isFunction, isReactor, function(f, r) {
    return reactor(function() {
      return (next(r)).then(function(arg) {
        var done, ref4, value;
        done = arg.done, value = arg.value;
        if (!done) {
          return ((ref4 = f(value)) != null ? typeof ref4.then === "function" ? ref4.then(function() {
            return {
              done: done,
              value: value
            };
          }) : void 0 : void 0) || {
            done: done,
            value: value
          };
        } else {
          return {
            done: done
          };
        }
      });
    });
  });

  Method.define(tee, isFunction, isIterator, function(f, i) {
    return iterator(function() {
      var done, ref4, ref5, value;
      ref4 = next(i), done = ref4.done, value = ref4.value;
      if (!done) {
        return {
          done: done,
          value: ((ref5 = f(value)) != null ? typeof ref5.then === "function" ? ref5.then(function() {
            return value;
          }) : void 0 : void 0) || value
        };
      } else {
        return {
          done: done
        };
      }
    });
  });

  tee = curry(binary(tee));

  throttle = curry(function(ms, i) {
    var last;
    last = 0;
    return reactor(async(function*() {
      var done, now, ref4, value;
      while (true) {
        ref4 = (yield next(i)), done = ref4.done, value = ref4.value;
        if (done) {
          break;
        }
        now = Date.now();
        if (now - last >= ms) {
          break;
        }
      }
      last = now;
      return {
        done: done,
        value: value
      };
    }));
  });

  pump = Method.create();

  isStreamLike = function(s) {
    return (s != null) && (isFunction(s.write)) && (isFunction(s.end));
  };

  Method.define(pump, isStreamLike, isDefined, function(s, x) {
    return pump(s, producer(x));
  });

  Method.define(pump, isStreamLike, isIterator, function(s, i) {
    return iterator(function() {
      var done, ref4, value;
      ref4 = next(i), done = ref4.done, value = ref4.value;
      if (done) {
        s.end();
      } else {
        s.write(value);
      }
      return {
        done: done,
        value: s
      };
    });
  });

  Method.define(pump, isStreamLike, isReactor, function(s, i) {
    return reactor(function() {
      return (next(i)).then(function(arg) {
        var done, value;
        done = arg.done, value = arg.value;
        if (done) {
          s.end();
        } else {
          s.write(value);
        }
        return {
          done: done,
          value: s
        };
      });
    });
  });

  pump = curry(binary(pump));

  module.exports = {
    map: map,
    accumulate: accumulate,
    select: select,
    filter: filter,
    reject: reject,
    project: project,
    compact: compact,
    partition: partition,
    take: take,
    takeN: takeN,
    where: where,
    lines: lines,
    tee: tee,
    throttle: throttle,
    pump: pump
  };

}).call(this);
