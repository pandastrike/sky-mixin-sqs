// Generated by CoffeeScript 1.12.4
(function() {
  var Base64Words, Crypto, Method, async, base64, base64URL, fromBase64Words, fs, isBuffer, isInteger, isString, join, md5, promise, push, randomBytes, randomKey, randomWord, randomWords, ref, ref1, ref2, toBase64Words;

  fs = require("fs");

  Crypto = require("crypto");

  Method = require("fairmont-multimethods").Method;

  ref = require("./type"), isBuffer = ref.isBuffer, isInteger = ref.isInteger, isString = ref.isString;

  Base64Words = require("base64-words");

  ref1 = require("./promise"), promise = ref1.promise, async = ref1.async;

  ref2 = require("./array"), join = ref2.join, push = ref2.push;

  md5 = Method.create();

  Method.define(md5, isString, function(string) {
    return Crypto.createHash('md5').update(string, 'utf-8').digest("hex");
  });

  Method.define(md5, isBuffer, function(buffer) {
    return Crypto.createHash('md5').update(buffer, 'binary').digest("hex");
  });

  base64 = Method.create();

  Method.define(base64, isString, function(string) {
    return base64(new Buffer(string));
  });

  Method.define(base64, isBuffer, function(buffer) {
    return buffer.toString('base64');
  });

  base64URL = function(buffer) {
    return base64(buffer).replace(/\+/g, '-').replace(/\//g, '_').replace(/\=+$/, '');
  };

  toBase64Words = function(buffer) {
    return Base64Words.fromBase64(base64URL(buffer));
  };

  fromBase64Words = function(string) {
    return new Buffer(Base64Words.toBase64(string), 'base64');
  };

  randomBytes = process.platform !== "win32" ? function(n) {
    return promise(function(resolve, reject) {
      return fs.open("/dev/urandom", "r", function(error, fd) {
        var buffer;
        buffer = Buffer.alloc ? Buffer.alloc(n) : new Buffer(n);
        return fs.read(fd, buffer, 0, n, 0, function(error, m) {
          if (n === m) {
            return resolve(buffer);
          } else {
            return reject("Unable to read " + n + " bytes from /dev/urandom");
          }
        });
      });
    });
  } : function(n) {
    return promise(function(resolve, reject) {
      return Crypto.randomBytes(n, function(error, buffer) {
        if (error == null) {
          return resolve(buffer);
        } else {
          return reject(error);
        }
      });
    });
  };

  randomKey = async(function*(n) {
    return base64URL((yield randomBytes(n)));
  });

  randomWord = (function() {
    var max;
    max = 0xffff - 0xffff % Base64Words.dictionary.length;
    return async(function*() {
      var buffer, i;
      while (true) {
        buffer = (yield randomBytes(2));
        i = buffer.readUInt16LE();
        if (i < max) {
          return Base64Words.dictionary[i % Base64Words.dictionary.length];
        }
      }
    });
  })();

  randomWords = Method.create();

  Method.define(randomWords, isInteger, function(bytes) {
    return randomWords({
      bytes: bytes
    });
  });

  Method.define(randomWords, (function(arg) {
    var bytes;
    bytes = arg.bytes;
    return isInteger(bytes);
  }), function(arg) {
    var bytes, words;
    bytes = arg.bytes;
    words = Math.ceil(8 * bytes / Math.log2(Base64Words.dictionary.length));
    return randomWords({
      words: words
    });
  });

  Method.define(randomWords, (function(arg) {
    var words;
    words = arg.words;
    return isInteger(words);
  }), async(function*(arg) {
    var ax, words;
    words = arg.words;
    ax = [];
    while (words-- !== 0) {
      push(ax, (yield randomWord()));
    }
    return join(ax, "-");
  }));

  module.exports = {
    md5: md5,
    base64: base64,
    base64URL: base64URL,
    toBase64Words: toBase64Words,
    fromBase64Words: fromBase64Words,
    randomBytes: randomBytes,
    randomKey: randomKey,
    randomWord: randomWord,
    randomWords: randomWords
  };

}).call(this);
