// Generated by CoffeeScript 1.12.4
(function() {
  var async, call, follow, isFunction, isGeneratorFunction, isObject, isPromise, lift, promise, ref, reject, resolve, unhandled,
    slice = [].slice;

  ref = require("./type"), isPromise = ref.isPromise, isObject = ref.isObject, isFunction = ref.isFunction, isGeneratorFunction = ref.isGeneratorFunction;

  unhandled = new Map;

  process.on("unhandledRejection", function(reason, p) {
    return console.warn("Warning: unhandled rejection for", p);
  });

  promise = function(executor) {
    return new Promise(executor);
  };

  reject = function(x) {
    return Promise.reject(x);
  };

  resolve = function(x) {
    return Promise.resolve(x);
  };

  follow = resolve;

  lift = function(f) {
    var key, proxy, value;
    if (isObject(f)) {
      proxy = {};
      for (key in f) {
        value = f[key];
        if (isFunction(value)) {
          proxy[key] = lift(value);
        }
      }
      return proxy;
    } else {
      return function() {
        var args;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        return promise(function(resolve, reject) {
          var error;
          try {
            return f.apply(null, slice.call(args).concat([function() {
              var _args, error;
              error = arguments[0], _args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
              if (error == null) {
                return resolve.apply(null, _args);
              } else {
                return reject(error);
              }
            }]));
          } catch (error1) {
            error = error1;
            return reject(error);
          }
        });
      };
    }
  };

  async = function(g) {
    if (!(isGeneratorFunction(g))) {
      throw new TypeError(g + " is not a generator function");
    }
    return function() {
      var args, self;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      self = this;
      return promise(function(resolve, reject) {
        var f, i, step;
        i = g.apply(self, args);
        f = function() {
          return i.next();
        };
        return (step = function(f) {
          var done, error, ref1, value;
          try {
            ref1 = f(), done = ref1.done, value = ref1.value;
          } catch (error1) {
            error = error1;
            reject(error);
          }
          if (done) {
            return resolve(value);
          } else {
            return follow(value).then(function(value) {
              return step(function() {
                return i.next(value);
              });
            })["catch"](function(error) {
              return step(function() {
                return i["throw"](error);
              });
            });
          }
        })(f);
      });
    };
  };

  call = function(f) {
    return async(f)();
  };

  module.exports = {
    promise: promise,
    resolve: resolve,
    follow: follow,
    reject: reject,
    lift: lift,
    async: async,
    call: call
  };

}).call(this);
