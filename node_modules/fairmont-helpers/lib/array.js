// Generated by CoffeeScript 1.12.4
(function() {
  var _, binary, cat, complement, compose, curry, deepEqual, dequeue, detach, difference, dupes, empty, enqueue, fifth, fill, findIndexOf, findLastIndexOf, first, flip, fourth, identity, includes, insert, intersection, join, last, nth, pair, partial, pluck, pop, push, random, range, ref, remove, rest, round, second, shift, shuffle, slice, some, sort, splice, ternary, third, unary, union, uniq, unique, uniqueBy, unshift,
    slice1 = [].slice,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  ref = require("fairmont-core"), curry = ref.curry, flip = ref.flip, compose = ref.compose, partial = ref.partial, _ = ref._, identity = ref.identity, unary = ref.unary, binary = ref.binary, ternary = ref.ternary;

  detach = require("./object").detach;

  deepEqual = require("./util").deepEqual;

  nth = curry(function(i, ax) {
    return ax[i - 1];
  });

  first = nth(1);

  second = nth(2);

  third = nth(3);

  fourth = nth(4);

  fifth = nth(5);

  last = function(arg) {
    var k, last, rest;
    rest = 2 <= arg.length ? slice1.call(arg, 0, k = arg.length - 1) : (k = 0, []), last = arg[k++];
    return last;
  };

  rest = function(arg) {
    var first, rest;
    first = arg[0], rest = 2 <= arg.length ? slice1.call(arg, 1) : [];
    return rest;
  };

  empty = function(x) {
    return x.length === 0;
  };

  includes = Array.prototype.includes ? curry(function(a, ax) {
    return ax.includes(a);
  }) : curry(function(a, ax) {
    return (ax.indexOf(a)) !== -1;
  });

  findIndexOf = curry(function(a, ax) {
    var i;
    if ((i = ax.indexOf(a)) !== -1) {
      return i;
    }
  });

  findLastIndexOf = curry(function(a, ax) {
    var i;
    if ((i = ax.lastIndexOf(a)) !== -1) {
      return i;
    }
  });

  some = curry(binary(detach(Array.prototype.some)));

  push = curry(function() {
    var a, ax;
    ax = arguments[0], a = 2 <= arguments.length ? slice1.call(arguments, 1) : [];
    ax.push.apply(ax, a);
    return ax;
  });

  pop = detach(Array.prototype.pop);

  shift = detach(Array.prototype.shift);

  unshift = detach(Array.prototype.unshift);

  enqueue = unshift;

  dequeue = pop;

  splice = curry(function(i, n, ax) {
    ax.splice(i, n);
    return ax;
  });

  insert = curry(ternary(function(ax, a, i) {
    ax.splice(i, 0, a);
    return ax;
  }));

  remove = curry(function(ax, a) {
    var i;
    if ((i = ax.indexOf(a)) !== -1) {
      ax.splice(i, 1);
    }
    return ax;
  });

  cat = detach(Array.prototype.concat);

  slice = curry(function(i, j, ax) {
    return ax.slice(i, j);
  });

  sort = curry(binary(detach(Array.prototype.sort)));

  join = curry(binary(detach(Array.prototype.join)));

  fill = curry(function(ax, a) {
    return ax.fill(a);
  });

  uniqueBy = curry(function(f, ax) {
    var a, b, bx, k, len;
    bx = [];
    for (k = 0, len = ax.length; k < len; k++) {
      a = ax[k];
      b = f(a);
      if (indexOf.call(bx, b) < 0) {
        bx.push(b);
      }
    }
    return bx;
  });

  unique = uniq = uniqueBy(identity);

  dupes = function(arg) {
    var a, ax, bx;
    a = arg[0], ax = 2 <= arg.length ? slice1.call(arg, 1) : [];
    if (empty(ax)) {
      return [];
    } else {
      bx = dupes(ax);
      if (indexOf.call(ax, a) >= 0 && !(indexOf.call(bx, a) >= 0)) {
        return [a].concat(slice1.call(bx));
      } else {
        return bx;
      }
    }
  };

  union = curry(compose(unique, cat));

  intersection = function() {
    var first, k, len, ref1, rest, results, x;
    first = arguments[0], rest = 2 <= arguments.length ? slice1.call(arguments, 1) : [];
    if (empty(rest)) {
      return first;
    } else {
      ref1 = intersection.apply(null, rest);
      results = [];
      for (k = 0, len = ref1.length; k < len; k++) {
        x = ref1[k];
        if (indexOf.call(first, x) >= 0) {
          results.push(x);
        }
      }
      return results;
    }
  };

  difference = curry(function(ax, bx) {
    var cx;
    cx = union(ax, bx);
    return cx.filter(function(c) {
      return (indexOf.call(ax, c) >= 0 && !(indexOf.call(bx, c) >= 0)) || (indexOf.call(bx, c) >= 0 && !(indexOf.call(ax, c) >= 0));
    });
  });

  complement = curry(function(ax, bx) {
    return ax.filter(function(c) {
      return !(indexOf.call(bx, c) >= 0);
    });
  });

  shuffle = function(ax) {
    var bx, i, j, ref1;
    bx = cat(ax);
    i = bx.length;
    if (!(i <= 1)) {
      while (--i > 0) {
        j = Math.floor(Math.random() * (i + 1));
        ref1 = [bx[j], bx[i]], bx[i] = ref1[0], bx[j] = ref1[1];
      }
      if (deepEqual(ax, bx)) {
        return shuffle(ax);
      } else {
        return bx;
      }
    } else {
      return bx;
    }
  };

  range = curry(function(start, finish) {
    var k, results;
    return (function() {
      results = [];
      for (var k = start; start <= finish ? k <= finish : k >= finish; start <= finish ? k++ : k--){ results.push(k); }
      return results;
    }).apply(this);
  });

  random = Math.random, round = Math.round;

  pluck = function(ax) {
    return ax[round(random() * (ax.length - 1))];
  };

  pair = curry(function(a, b) {
    return [a, b];
  });

  module.exports = {
    first: first,
    second: second,
    third: third,
    fourth: fourth,
    fifth: fifth,
    nth: nth,
    last: last,
    rest: rest,
    empty: empty,
    includes: includes,
    findIndexOf: findIndexOf,
    findLastIndexOf: findLastIndexOf,
    uniqueBy: uniqueBy,
    unique: unique,
    uniq: uniq,
    dupes: dupes,
    union: union,
    intersection: intersection,
    difference: difference,
    complement: complement,
    push: push,
    pop: pop,
    shift: shift,
    unshift: unshift,
    enqueue: enqueue,
    dequeue: dequeue,
    splice: splice,
    insert: insert,
    remove: remove,
    cat: cat,
    slice: slice,
    join: join,
    fill: fill,
    shuffle: shuffle,
    range: range,
    pluck: pluck,
    pair: pair
  };

}).call(this);
