// Generated by CoffeeScript 1.10.0
(function() {
  var _, apply, binary, compose, curry, flip, given, identity, negate, noOp, once, partial, pipe, spread, substitute, ternary, unary, wrap,
    slice = [].slice;

  noOp = function() {};

  identity = function(x) {
    return x;
  };

  wrap = function(x) {
    return function() {
      return x;
    };
  };

  curry = function(f) {
    var g;
    return g = function() {
      var ax;
      ax = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if (ax.length >= f.length) {
        return f.apply(null, ax);
      } else {
        switch (f.length - ax.length) {
          case 1:
            return function(x) {
              return f.apply(null, slice.call(ax).concat([x]));
            };
          case 2:
            return binary(curry(function(x, y) {
              return f.apply(null, slice.call(ax).concat([x], [y]));
            }));
          case 3:
            return ternary(curry(function(x, y, z) {
              return f.apply(null, slice.call(ax).concat([x], [y], [z]));
            }));
          default:
            return function() {
              var bx;
              bx = 1 <= arguments.length ? slice.call(arguments, 0) : [];
              return g.apply(null, slice.call(ax).concat(slice.call(bx)));
            };
        }
      }
    };
  };

  _ = {};

  substitute = curry(function(ax, bx) {
    var a, i, j, len, results;
    i = 0;
    results = [];
    for (j = 0, len = ax.length; j < len; j++) {
      a = ax[j];
      if (a === _) {
        results.push(bx[i++]);
      } else {
        results.push(a);
      }
    }
    return results;
  });

  partial = function() {
    var ax, f;
    f = arguments[0], ax = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    return function() {
      var bx;
      bx = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return f.apply(null, substitute(ax, bx));
    };
  };

  flip = function(f) {
    switch (f.length) {
      case 1:
        return f;
      case 2:
        return function(y, x) {
          return f(x, y);
        };
      case 3:
        return function(z, y, x) {
          return f(x, y, z);
        };
      default:
        return function() {
          var ax;
          ax = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          return f.apply(null, ax.reverse());
        };
    }
  };

  compose = function() {
    var f, fx, g, j;
    fx = 2 <= arguments.length ? slice.call(arguments, 0, j = arguments.length - 1) : (j = 0, []), f = arguments[j++];
    if (fx.length === 0) {
      return f;
    } else {
      g = compose.apply(null, fx);
      return function() {
        var ax, fax, ref;
        ax = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        if (((ref = (fax = f.apply(null, ax))) != null ? ref.then : void 0) != null) {
          return fax.then(g);
        } else {
          return g(fax);
        }
      };
    }
  };

  pipe = flip(compose);

  spread = function(f) {
    return function(ax) {
      return f.apply(null, ax);
    };
  };

  unary = function(f) {
    return function(x) {
      return f(x);
    };
  };

  binary = function(f) {
    return function(x, y) {
      return f.apply(null, arguments);
    };
  };

  ternary = function(f) {
    return function(x, y, z) {
      return f.apply(null, arguments);
    };
  };

  apply = function() {
    var args, f;
    f = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    return f.apply(null, args);
  };

  negate = function(f) {
    return function() {
      return !(f.apply(null, arguments));
    };
  };

  once = function(f) {
    return function() {
      var k;
      k = f();
      f = wrap(k);
      return k;
    };
  };

  given = function(f) {
    return f();
  };

  module.exports = {
    noOp: noOp,
    identity: identity,
    wrap: wrap,
    curry: curry,
    _: _,
    substitute: substitute,
    partial: partial,
    flip: flip,
    compose: compose,
    pipe: pipe,
    spread: spread,
    unary: unary,
    binary: binary,
    ternary: ternary,
    apply: apply,
    negate: negate,
    once: once,
    given: given
  };

}).call(this);
