"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _amen = require("amen");

var _filters = require("../src/filters");

function _awaitAsyncGenerator(value) { return new _AwaitValue(value); }

function _wrapAsyncGenerator(fn) { return function () { return new _AsyncGenerator(fn.apply(this, arguments)); }; }

function _AsyncGenerator(gen) { var front, back; function send(key, arg) { return new Promise(function (resolve, reject) { var request = { key: key, arg: arg, resolve: resolve, reject: reject, next: null }; if (back) { back = back.next = request; } else { front = back = request; resume(key, arg); } }); } function resume(key, arg) { try { var result = gen[key](arg); var value = result.value; var wrappedAwait = value instanceof _AwaitValue; Promise.resolve(wrappedAwait ? value.wrapped : value).then(function (arg) { if (wrappedAwait) { resume("next", arg); return; } settle(result.done ? "return" : "normal", arg); }, function (err) { resume("throw", err); }); } catch (err) { settle("throw", err); } } function settle(type, value) { switch (type) { case "return": front.resolve({ value: value, done: true }); break; case "throw": front.reject(value); break; default: front.resolve({ value: value, done: false }); break; } front = front.next; if (front) { resume(front.key, front.arg); } else { back = null; } } this._invoke = send; if (typeof gen.return !== "function") { this.return = undefined; } }

if (typeof Symbol === "function" && Symbol.asyncIterator) { _AsyncGenerator.prototype[Symbol.asyncIterator] = function () { return this; }; }

_AsyncGenerator.prototype.next = function (arg) { return this._invoke("next", arg); };

_AsyncGenerator.prototype.throw = function (arg) { return this._invoke("throw", arg); };

_AsyncGenerator.prototype.return = function (arg) { return this._invoke("return", arg); };

function _AwaitValue(value) { this.wrapped = value; }

function _asyncIterator(iterable) { var method; if (typeof Symbol === "function") { if (Symbol.asyncIterator) { method = iterable[Symbol.asyncIterator]; if (method != null) return method.call(iterable); } if (Symbol.iterator) { method = iterable[Symbol.iterator]; if (method != null) return method.call(iterable); } } throw new TypeError("Object is not async iterable"); }

var add, assert, follow, merge, odd, spec, square;
assert = require("assert");
({
  odd,
  merge,
  follow
} = require("panda-parchment")); // we need to do things with the values

square = function (x) {
  return x * x;
};

add = function (x, y) {
  return x + y;
};

spec = function (name, {
  expected,
  filter,
  iterable
}) {
  return (0, _amen.test)(name, [(0, _amen.test)("iterator", function () {
    var x;
    return assert.deepEqual(expected, function () {
      var ref, results;
      ref = filter(iterable);
      results = [];

      for (x of ref) {
        results.push(x);
      }

      return results;
    }());
  }), (0, _amen.test)("reactor", async function () {
    var r, x;

    r =
    /*#__PURE__*/
    function () {
      var _ref = _wrapAsyncGenerator(function* () {
        var results, x;
        results = [];
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;

        var _iteratorError;

        try {
          for (var _iterator = _asyncIterator(iterable), _step, _value; _step = yield _awaitAsyncGenerator(_iterator.next()), _iteratorNormalCompletion = _step.done, _value = yield _awaitAsyncGenerator(_step.value), !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {
            x = _value;
            results.push((yield x));
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              yield _awaitAsyncGenerator(_iterator.return());
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        return results;
      });

      return function r() {
        return _ref.apply(this, arguments);
      };
    }();

    return assert.deepEqual(expected, (await async function () {
      var ref, results;
      ref = filter(r);
      results = [];
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;

      var _iteratorError2;

      try {
        for (var _iterator2 = _asyncIterator(ref), _step2, _value2; _step2 = await _iterator2.next(), _iteratorNormalCompletion2 = _step2.done, _value2 = await _step2.value, !_iteratorNormalCompletion2; _iteratorNormalCompletion2 = true) {
          x = _value2;
          results.push(x);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            await _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return results;
    }()));
  })]);
};

var _default = [spec("map", {
  expected: [1, 4, 9, 16],
  filter: (0, _filters.map)(square),
  iterable: [1, 2, 3, 4]
}), spec("accumulate", {
  expected: [1, 3, 6, 10],
  filter: (0, _filters.accumulate)(add, 0),
  iterable: [1, 2, 3, 4]
}), spec("select", {
  expected: [1, 3, 5],
  filter: (0, _filters.select)(odd),
  iterable: [1, 2, 3, 4, 5]
}), spec("tee", {
  expected: [1, 2, 3, 4],
  filter: (0, _filters.tee)(square),
  iterable: [1, 2, 3, 4]
}), spec("partition", {
  expected: [[1, 2], [3, 4]],
  filter: (0, _filters.partition)(2),
  iterable: [1, 2, 3, 4]
}), spec("take", {
  expected: [1, 2, 3],
  filter: (0, _filters.take)(function (x) {
    return x <= 3;
  }),
  iterable: [1, 2, 3, 4]
}), (0, _amen.test)("throttle"), spec("lines", {
  expected: ["one", "two", "three"],
  filter: _filters.lines,
  iterable: ["one\ntwo", "\nthree"]
})];
exports.default = _default;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9keW9kZXIvcmVwb3MvcGFuZGEtcml2ZXIvdGVzdC9maWx0ZXJzLmNvZmZlZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7O0FBR0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBSEEsSUFBQSxHQUFBLEVBQUEsTUFBQSxFQUFBLE1BQUEsRUFBQSxLQUFBLEVBQUEsR0FBQSxFQUFBLElBQUEsRUFBQSxNQUFBO0FBQ0EsTUFBQSxHQUFTLE9BQUEsQ0FBQSxRQUFBLENBQVQ7QUFLQSxDQUFBO0FBQUEsRUFBQSxHQUFBO0FBQUEsRUFBQSxLQUFBO0FBQUEsRUFBQTtBQUFBLElBQXVCLE9BQUEsQ0FOdkIsaUJBTXVCLENBQXZCLEU7O0FBR0EsTUFBQSxHQUFTLFVBQUEsQ0FBQSxFQUFBO1NBQU8sQ0FBQSxHQUFJLEM7QUFBWCxDQUFUOztBQUNBLEdBQUEsR0FBTSxVQUFBLENBQUEsRUFBQSxDQUFBLEVBQUE7U0FBVSxDQUFBLEdBQUksQztBQUFkLENBQU47O0FBRUEsSUFBQSxHQUFPLFVBQUEsSUFBQSxFQUFPO0FBQUEsRUFBQSxRQUFBO0FBQUEsRUFBQSxNQUFBO0FBQVAsRUFBQTtBQUFPLENBQVAsRUFBQTtTQUVMLGdCQUFBLElBQUEsRUFBVyxDQUNULGdCQUFBLFVBQUEsRUFBaUIsWUFBQTtBQUNmLFFBQUEsQ0FBQTtXQUFBLE1BQU0sQ0FBTixTQUFBLENBQUEsUUFBQSxFOztBQUNLLE1BQUEsR0FBQSxHQUFBLE1BQUEsQ0FBQSxRQUFBLENBQUE7QUFBQSxNQUFBLE9BQUEsR0FBQSxFQUFBOztBQUFBLFdBQUEsQ0FBQSxJQUFBLEdBQUEsRUFBQTtxQkFBRixDO0FBQUU7OztBQURMLEssRUFBQSxDO0FBRk8sR0FDVCxDQURTLEVBS1QsZ0JBQUEsU0FBQSxFQUFnQixrQkFBQTtBQUNkLFFBQUEsQ0FBQSxFQUFBLENBQUE7O0FBQUEsSUFBQSxDQUFBO0FBQUE7QUFBQTtBQUFBLHFDQUFJLGFBQUE7QUFBRyxZQUFBLE9BQUEsRUFBQSxD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QTNCYSxFQWdDYixnQkFoQ2EsVUFnQ2IsQ0FoQ2EsRUFrQ2IsSUFBQSxDQUFBLE9BQUEsRUFDRTtBQUFBLEVBQUEsUUFBQSxFQUFVLENBQUEsS0FBQSxFQUFBLEtBQUEsRUFBVixPQUFVLENBQVY7QUFDQSxFQUFBLE1BQUEsRUFEQSxjQUFBO0FBRUEsRUFBQSxRQUFBLEVBQVUsQ0FBQSxVQUFBLEVBQUEsU0FBQTtBQUZWLENBREYsQ0FsQ2EsQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7dGVzdH0gZnJvbSBcImFtZW5cIlxuYXNzZXJ0ID0gcmVxdWlyZSBcImFzc2VydFwiXG5cbmltcG9ydCB7bWFwLCBwcm9qZWN0LCBhY2N1bXVsYXRlLCBzZWxlY3QsIGZpbHRlciwgcmVqZWN0LCBjb21wYWN0LFxuICB0ZWUsIHBhcnRpdGlvbiwgdGFrZSwgbGltaXQsIGxpbmVzLCB0aHJvdHRsZX0gZnJvbSBcIi4uL3NyYy9maWx0ZXJzXCJcblxue29kZCwgbWVyZ2UsIGZvbGxvd30gPSByZXF1aXJlIFwicGFuZGEtcGFyY2htZW50XCJcblxuIyB3ZSBuZWVkIHRvIGRvIHRoaW5ncyB3aXRoIHRoZSB2YWx1ZXNcbnNxdWFyZSA9ICh4KSAtPiB4ICogeFxuYWRkID0gKHgsIHkpIC0+IHggKyB5XG5cbnNwZWMgPSAobmFtZSwge2V4cGVjdGVkLCBmaWx0ZXIsIGl0ZXJhYmxlfSkgLT5cblxuICB0ZXN0IG5hbWUsIFtcbiAgICB0ZXN0IFwiaXRlcmF0b3JcIiwgLT5cbiAgICAgIGFzc2VydC5kZWVwRXF1YWwgZXhwZWN0ZWQsXG4gICAgICAgICh4IGZvciB4IGZyb20gZmlsdGVyIGl0ZXJhYmxlKVxuXG4gICAgdGVzdCBcInJlYWN0b3JcIiwgLT5cbiAgICAgIHIgPSAtPiB5aWVsZCB4IGZvciBhd2FpdCB4IGZyb20gaXRlcmFibGVcbiAgICAgIGFzc2VydC5kZWVwRXF1YWwgZXhwZWN0ZWQsXG4gICAgICAgICh4IGZvciBhd2FpdCB4IGZyb20gZmlsdGVyIHIpXG4gIF1cblxuZXhwb3J0IGRlZmF1bHQgW1xuXG4gIHNwZWMgXCJtYXBcIixcbiAgICBleHBlY3RlZDogWzEsIDQsIDksIDE2XVxuICAgIGZpbHRlcjogbWFwIHNxdWFyZVxuICAgIGl0ZXJhYmxlOiBbMS4uNF1cblxuICBzcGVjIFwiYWNjdW11bGF0ZVwiLFxuICAgIGV4cGVjdGVkOiBbMSwgMywgNiwgMTBdXG4gICAgZmlsdGVyOiBhY2N1bXVsYXRlIGFkZCwgMFxuICAgIGl0ZXJhYmxlOiBbMS4uNF1cblxuICBzcGVjIFwic2VsZWN0XCIsXG4gICAgZXhwZWN0ZWQ6IFsxLCAzLCA1XVxuICAgIGZpbHRlcjogc2VsZWN0IG9kZFxuICAgIGl0ZXJhYmxlOiBbMS4uNV1cblxuICBzcGVjIFwidGVlXCIsXG4gICAgZXhwZWN0ZWQ6IFsxLi40XVxuICAgIGZpbHRlcjogdGVlIHNxdWFyZVxuICAgIGl0ZXJhYmxlOiBbMS4uNF1cblxuICBzcGVjIFwicGFydGl0aW9uXCIsXG4gICAgZXhwZWN0ZWQ6IFtbMSwgMl0sIFszLCA0XV1cbiAgICBmaWx0ZXI6IHBhcnRpdGlvbiAyXG4gICAgaXRlcmFibGU6IFsxLi40XVxuXG4gIHNwZWMgXCJ0YWtlXCIsXG4gICAgZXhwZWN0ZWQ6IFsxLi4zXVxuICAgIGZpbHRlcjogdGFrZSAoeCkgLT4geCA8PSAzXG4gICAgaXRlcmFibGU6IFsxLi40XVxuXG4gIHRlc3QgXCJ0aHJvdHRsZVwiXG5cbiAgc3BlYyBcImxpbmVzXCIsXG4gICAgZXhwZWN0ZWQ6IFsgXCJvbmVcIiwgXCJ0d29cIiwgXCJ0aHJlZVwiIF1cbiAgICBmaWx0ZXI6IGxpbmVzXG4gICAgaXRlcmFibGU6IFsgXCJvbmVcXG50d29cIiwgXCJcXG50aHJlZVwiIF1cblxuXVxuIl0sInNvdXJjZVJvb3QiOiIifQ==
//# sourceURL=/Users/dyoder/repos/panda-river/test/filters.coffee